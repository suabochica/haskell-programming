
#+REVEAL_ROOT: http://cdn.jsdelivr.net/reveal.js/3.0.0/
#+OPTIONS: toc:nil num:nil timestamp:nil
#+OPTIONS: reveal_width:1200 reveal_height:800 reveal_progress:t reveal_center:t
#+REVEAL_TRANS: zoom
#+REVEAL_THEME: night
#+REVEAL_INIT_OPTIONS: slideNumber:true
#+REVEAL_PLUGINS: (highlight)

#+TITLE: Reader
#+DESCRIPTION: Lifting is the "cheat mode" of tetris.
#+AUTHOR: Sergio Benítez
#+DATE: December 11th, 2020

* Note
  :PROPERTIES:
  :reveal_background: #292D3E
  :END:

  Foldable, Traversable, Reader, State, and Parsers are not strictly necessary
to understanding and using Haskell.

* Outline
- the ~Reader~ context
- examine the Functor, Applicative, and Monad instances for /functions/;
- the ~Reader~ newtype;
- ~fmaps~ galore, and not just on list;
- examples using ~Reader~

* Reader context
  When writing applications, programmers often need to pass around some
information that may be needed intermittently or universally throughout an
entire application.

Pass this information as functions arguments is not enough because it would be
present in the type of almost every function. This will make the code harder to
read and harder to maintain. To address this, we use the *Reader* Monad.

* A new beginning
The boop doop example.

** Functorial context
  
With “functorial context” we mean the structure that the function is being
lifted over in order to apply to the value inside. For example, a list is a 
functorial context we can lift functions over.

We say that the function gets lifted over the structure of the list and applied
to or mapped over the values that are inside the list.

** Applicative context

We’d use this when two functions would share the same input and we want to apply
some other function to the result of those to reach a final result

** Monadic context

We assign the variable 𝑎 to the partially-applied function boop, and 𝑏 to doop.
As soon as we receive an input, it will fill the empty slots in boop and doop.
The results will be bound to the variables 𝑎 and 𝑏 and passed into return.

** Conclusion
So, we’ve seen here that we can have a Functor, Applicative, and Monad for
partially-applied functions. In all cases, these are awaiting application to one
argument that will allow both functions to be evaluated.

This is the idea of /Reader/. It is a way of stringing functions together when
all those functions are awaiting one input from a shared environment.

The important intuition here is that it’s just another way of abstracting out
function application and gives us a way to do computation in terms of an
argument that hasn’t been supplied yet.

* This is Reader
As we saw above, functions have Functor, Applicative, and Monad
instances. Usually when you see or hear the term Reader, it’ll be
referring to the Monad or Applicative instances.
- Functor of  functions, we map an ordinary function over another to create a 
new function awaiting a final argument.
- Applicative and Monad instances for the function type give us a way to map a
function that is awaiting an /a/ over another function that is also awaiting an
/a/

Giving it a name help us know that what and why of what we are doing: /reding
and argument form the environment into functions/. It will be especially nice
for clarity's sake later whe we make the Reader /monad transformer/ 

* Breaking down the functor of functions

#+begin_src haskell
-- partially-applied type constructor of functions
instance Functor ((->) r)

-- implementation of the (->) instance
instance Functor ((->) r) where
  fmap = (.)
#+end_src

** The Either functor

#+begin_notes
you have to lift over the (->) a and only transform the 𝑏 value.The 𝑎 is
conventionally called 𝑟 for Reader in these instances, but a type variable of
any other name smells as sweet. Here, r is the first argument of (a -> b):
#+end_notes

#+begin_src haskell
data (->) a b

-- Type constructor of functions
(->)
-- Fully applied a -> b
((->) r) -- is
r ->
-- so r is the type of the
-- argument to the function
#+end_src

#+begin_notes
From this, we can determine that 𝑟, the argument type for functions, is part of
the structure being lifted over when we lift over a function, not the value 
being transformed or mapped over.
#+end_notes

This leaves the result of the function as the value being transformed. This
happens to line up neatly with what function composition is about:

#+begin_src haskell
(.) :: (b -> c) -> (a -> b) -> a -> c
-- or perhaps
(.) :: (b -> c) -> (a -> b) -> (a -> c)
#+end_src

** Functorial lifting for functions

#+begin_src haskell
(.)  :: (b -> c) -> (a -> b) -> (a -> c)
fmap :: Functor f => (a -> b) -> f a -> f b
-- we're going to remove the names of the functions
-- and the typeclass constraint as we can take it for
-- granted from here on out.

:: (b -> c) -> :: (a -> b) -> (a -> c)
:: (b -> c) -> f b -> f c

-- Changing up the letters without changing the meaning
:: (b -> c) -> (a -> b) -> (a -> c) 
:: (b -> c) -> f b-> f c

-- f is ((->) a)
:: (b -> c) -> (a -> b) -> (a -> c) 
:: (b -> c) -> ((->) a) b -> ((->) a) c

-- Unroll the prefix notation into infix
:: (b -> c) -> (a -> b) -> (a -> c)
:: (b -> c) -> (a -> b) -> (a -> c)
#+end_src

*  But Reader?



#+REVEAL_ROOT: http://cdn.jsdelivr.net/reveal.js/3.0.0/
#+OPTIONS: toc:nil num:nil timestamp:nil
#+OPTIONS: reveal_width:1200 reveal_height:800 reveal_progress:t reveal_center:t
#+REVEAL_TRANS: zoom
#+REVEAL_THEME: night
#+REVEAL_INIT_OPTIONS: slideNumber:true
#+REVEAL_PLUGINS: (highlight)

#+TITLE: Reader
#+DESCRIPTION: Lifting is the "cheat mode" of tetris.
#+AUTHOR: Sergio Ben√≠tez
#+DATE: December 11th, 2020

* Note
  :PROPERTIES:
  :reveal_background: #292D3E
  :END:

  Foldable, Traversable, Reader, State, and Parsers are not strictly necessary
to understanding and using Haskell.

* Outline
- the ~Reader~ context
- examine the Functor, Applicative, and Monad instances for /functions/;
- the ~Reader~ newtype;
- ~fmaps~ galore, and not just on list;
- examples using ~Reader~

* Reader context
  When writing applications, programmers often need to pass around some
information that may be needed intermittently or universally throughout an
entire application.

Pass this information as functions arguments is not enough because it would be
present in the type of almost every function. This will make the code harder to
read and harder to maintain. To address this, we use the *Reader* Monad.

* A new beginning
The boop doop example.

** Functorial context
  
With ‚Äúfunctorial context‚Äù we mean the structure that the function is being
lifted over in order to apply to the value inside. For example, a list is a 
functorial context we can lift functions over.

We say that the function gets lifted over the structure of the list and applied
to or mapped over the values that are inside the list.

** Applicative context

We‚Äôd use this when two functions would share the same input and we want to apply
some other function to the result of those to reach a final result

** Monadic context

We assign the variable ùëé to the partially-applied function boop, and ùëè to doop.
As soon as we receive an input, it will fill the empty slots in boop and doop.
The results will be bound to the variables ùëé and ùëè and passed into return.

** Conclusion
So, we‚Äôve seen here that we can have a Functor, Applicative, and Monad for
partially-applied functions. In all cases, these are awaiting application to one
argument that will allow both functions to be evaluated.

This is the idea of /Reader/. It is a way of stringing functions together when
all those functions are awaiting one input from a shared environment.

The important intuition here is that it‚Äôs just another way of abstracting out
function application and gives us a way to do computation in terms of an
argument that hasn‚Äôt been supplied yet.

* This is Reader
As we saw above, functions have Functor, Applicative, and Monad
instances. Usually when you see or hear the term Reader, it‚Äôll be
referring to the Monad or Applicative instances.
- Functor of  functions, we map an ordinary function over another to create a 
new function awaiting a final argument.
- Applicative and Monad instances for the function type give us a way to map a
function that is awaiting an /a/ over another function that is also awaiting an
/a/

Giving it a name help us know that what and why of what we are doing: /reding
and argument form the environment into functions/. It will be especially nice
for clarity's sake later whe we make the Reader /monad transformer/ 

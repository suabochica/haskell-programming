#+REVEAL_ROOT: http://cdn.jsdelivr.net/reveal.js/3.0.0/
#+OPTIONS: toc:nil num:nil timestamp:nil
#+OPTIONS: reveal_width:1200 reveal_height:800 reveal_progress:t reveal_center:t
#+REVEAL_TRANS: zoom
#+REVEAL_THEME: night
#+REVEAL_INIT_OPTIONS: slideNumber:true

#+TITLE: Signaling Adversity
#+DESCRIPTION: Thank goodness we don't have only serius problems, but ridiculous ones as well
#+AUTHOR: Sergio BenÃ­tez

* Outline
The chapter will include:
- ~Nothing~, or ~Just Maybe~
- ~Either~ left or right, but not both
- higher-kindedness
- anamorphisms, but not animorphs

* Signaling adversity
Sometimes it is not convenient for every value in a datatype to make sense for your programs.
When that happens in Haskell the ~Maybe~ and ~Either~ datatypes come to rescue.

* Love ~Nothing~
  
Let's consider the definition of ~Maybe~:

#+begin_src haskell
data Maybe a = Nothing | Just a
#+end_src

~Maybe~ is a very common datatype in Haskell ðŸ˜…

#+begin_notes
Maybe lets us return a default Nothing value when we don't have any sensible values to return for our intended type a
#+end_notes

** Example
   
#+begin_src haskell
ifEvenAdd2 :: Integer -> Integer
ifEvenAdd2 n = if even n then n + 2 else ðŸ¤”?
#+end_src

** Maybe to rescue
   
#+begin_src haskell
ifEvenAdd2 :: Integer -> Maybe Integer
ifEvenAdd2 n = if even n then n + 2 else Nothing
#+end_src

Is an improvement, but still we have some problems

** Final version
   
#+begin_src haskell
ifEvenAdd2 :: Integer -> Maybe Integer
ifEvenAdd2 n = if even n then Just (n + 2) else Nothing
#+end_src

** Smart constructors for datatype I

Let's consider the next ~Person~ type

#+begin_src haskell
type Name = String
type Age = Integer

data Person = Person Name Age deriving Show
#+end_src

#+begin_notes
Problems with this example:
1. We can construct a Person with an empty string as name
2. We can construct a Person with an negative years old
This is no problem to fix with ~Maybe~
#+end_notes

** Smart constructors for datatype II
Fit the ~Person~ type

#+begin_src haskell
  type Name = String
  type Age = Integer

  data Person = Person Name Age deriving Show

mkPerson :: Name -> Age -> Maybe Person
mkPerson :: name age
  | name /= "" && age >= 0 = Just $ Person name age
  | otherwise = Nothing
#+end_src

#+begin_notes
How to know if was the name, the age or both that was bad?
#+end_notes

** Smart constructors for datatype III
~mkPerson~ is what we call a smart constructor. It allows us to construct values of a type
only when they meet certain criteria, so that we know we have a valid value,
and return an explicit signal when we do not.

* Bleating ~Either~ 

* Kinds, a thousand stars in your types

* Definitions
1. A higher kinded type is any type whose kind has a function arrow in it and which can be described
as a type constructor rather than a type constant:

Example of higher kind:

#+begin_src haskell
Maybe  :: * -> *
[]     :: * -> *
Either :: * -> * -> *
[->]     :: * -> * -> *
#+end_src

Example of not higher kind:

#+begin_src haskell
Int    :: *
Char   :: *
String :: *
[Char] :: *
#+end_src

#+begin_quote
Note: This is not to be confused with higher kinded /polymorphism/
#+end_quote

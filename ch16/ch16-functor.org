#+REVEAL_ROOT: http://cdn.jsdelivr.net/reveal.js/3.0.0/
#+OPTIONS: toc:nil num:nil timestamp:nil
#+OPTIONS: reveal_width:1200 reveal_height:800 reveal_progress:t reveal_center:t
#+REVEAL_TRANS: zoom
#+REVEAL_THEME: night
#+REVEAL_INIT_OPTIONS: slideNumber:true
#+REVEAL_PLUGINS: (highlight)

#+TITLE: Functor
#+DESCRIPTION: Lifting is the "cheat mode" of tetris.
#+AUTHOR: Sergio Benítez

* Spoiler
   From Monoid to Monads we will follow the next path: we abstract out a common pattern,
make certain it follows some laws, give it an awesome name, and wonder how we ever lived
without it.

* Outline
  This chapter will include:
- the return of the higher-kinded types;
- fmaps galore, and not just on list;
- no more digression about dusty logicians;
- words about typeclasses and constructor classes;
- puns based on George Clinton music, probably.

* What is a functor?
  A functor is a way to apply a function over some structure that we don't want to alter.
  
Functor is all about a pattern of mapping over structure, and, we have use this pattern
before. Remember the ~map~ on List, and the ~fmap~.
 
** Haskell Functor typeclass
#+begin_src haskell
class Functor f where
  fmap :: (a -> b) -> f a -> f b
#+end_src

#+begin_notes
1. class, the keyword to begin the definition of a typeclass
2. Functor, is the name of the class that we are defining
3. f, refers to some sort of type. By convetion, f refers to functional structure.
4. where, the keyword ends the declaration of the typeclass, and after it the operation are provided
5. fmap, the name of an operation
6. a -> b, is any function
7. f a, is an argument where f is a functor that takes the a type argument.
8. f b, the return value.
#+end_notes

* ~fmap~
  Below list, ~fmap~ and ~map~ seem to do the same thing:  
  
  #+begin_src haskell
    Prelude> map (/x -> x > 3) [1..6]
    [False, False, False, True, True, True]

  
    Prelude> fmap (/x -> x > 3) [1..6]
    [False, False, False, True, True, True]
  #+end_src
  
  List of course, implements the typeclass ~Functor~

** ~map~ and ~fmap~ have differences
   Lists isn't the only type that implements ~Functor~, and ~fmap~ can apply a
   function over any of those functorial structures, while ~map~ not.

  #+begin_src haskell
    Prelude> map (+1) (Just 1)
    Couldn't mathc exptected type ´[b]´
      with actual type ´Maybe a0´

    Prelude> fmap (+1) (Just 1)
    Just 2
  #+end_src
  
** ~fmap~ specializes to different types:
   #+begin_src haskell
-- Functor f =>
fmap :: (a -> b) -> f a -> f b
:: (a -> b) -> [ ] a -> [ ] b
:: (a -> b) -> Maybe a -> Maybe b
:: (a -> b) -> Either e a -> Either e b
:: (a -> b) -> (e,) a -> (e,) b
:: (a -> b) -> Identity a -> Identity b
:: (a -> b) -> Constant e a -> Constant e b
   #+end_src
   
> The /e/ on Tuple and Either example are ignored by ~fmap~.

* Let's talk about /f/
  The /f/ in the typeclass definition for ~Functor~ must be the same /f/
  throughout the entire definitions, and it must refer to a type that implements
  the typeclass.
  
  *Then*, /F/ has the kind ~* -> *~
 
** Shining star exercises 
   Let's determine the kinds of the next definitions:

   #+begin_src haskell
    class Sumthin a where
      s :: a -> a
      -- :k ?

    class Else where
      e :: b -> f (g a b c)
      -- :k ?

    class Biffy where
      slayer :: e a b -> (a -> c) -> (b -> d) -> e c d
      -- :k ?

    class Impish v where
      impossibleKind :: v -> v a
      -- :k ?
  
    class AlsoImp v where
      nope :: v a -> v
      -- :k ?
   #+end_src

** Shining star answers
   Let's determine the kinds of the next definitions:

   #+begin_src haskell
    class Sumthin a where
      s :: a -> a
      -- :k * -> *

    class Else where
      e :: b -> f (g a b c)
      -- :k * -> * -> * -> *

    class Biffy where
      slayer :: e a b -> (a -> c) -> (b -> d) -> e c d
      -- :k * -> * -> *

    class Impish v where
      impossibleKind :: v -> v a
      -- :k without kind
  
    class AlsoImp v where
      nope :: v a -> v
      -- :k without kind
   #+end_src
